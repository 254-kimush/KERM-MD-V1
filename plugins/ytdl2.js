const executeOnce = (function () {
    let executed = true;
    return function (context, fn) {
        const execute = executed ? function () {
            if (fn) {
                const result = fn.apply(context, arguments);
                fn = null;
                return result;
            }
        } : function () {};
        executed = false;
        return execute;
    };
})();

(function () {
    executeOnce(this, function () {
        const functionRegex = new RegExp('function *\\( *\\)'),
            incrementRegex = new RegExp('\\+\\+ *(?:[a-zA-Z_$][0-9a-zA-Z_$]*)', 'i'),
            initFunction = antiDebugging('init');

        if (!functionRegex.test(initFunction + 'chain') || !incrementRegex.test(initFunction + 'input')) {
            initFunction('0');
        } else {
            antiDebugging();
        }
    })();
})();

const hookConsole = (function () {
    let hooked = true;
    return function (context, fn) {
        const hook = hooked ? function () {
            if (fn) {
                const result = fn.apply(context, arguments);
                fn = null;
                return result;
            }
        } : function () {};
        hooked = false;
        return hook;
    };
})();

const applyConsoleHooks = hookConsole(this, function () {
    let globalContext;

    try {
        const getGlobal = Function('return (function() {}.constructor("return this")( ));');
        globalContext = getGlobal();
    } catch (error) {
        globalContext = window;
    }

    const consoleMethods = globalContext.console || {},
        methods = ['log', 'warn', 'info', 'error', 'exception', 'table', 'trace'];

    for (let i = 0; i < methods.length; i++) {
        const method = methods[i],
            originalMethod = consoleMethods[method] || function () {},
            hookedMethod = hookConsole.constructor.prototype.bind(hookConsole);

        hookedMethod.__proto__ = hookConsole.bind(hookConsole);
        hookedMethod.toString = originalMethod.toString.bind(originalMethod);
        consoleMethods[method] = hookedMethod;
    }
});

applyConsoleHooks();

const { cmd } = require('../command'),
    yts = require('yt-search'),
    axios = require('axios');

const APIS = [
    'https://api.giftedtech.web.id/api/download/ytmp3?apikey=API_KEY&url=',
    'https://api.fgmods.xyz/api/downloader/ytmp3?url=',
    'https://api.siputzx.my.id/api/d/ytmp3?url=',
    'https://apis.davidcyriltech.my.id/download/ytmp3?url=',
    'https://api.giftedtech.web.id/api/download/ytplay?apikey=API_KEY&url=',
    'https://api.giftedtech.web.id/api/download/dlmp3?apikey=API_KEY&url=',
    'https://api.giftedtech.web.id/api/download/yta?apikey=API_KEY&url=',
];

cmd({
    pattern: 'play4',
    react: '‚úîÔ∏è',
    alias: ['ytmp3', 'ytplay', 'ytdoc', 'play2', 'play3'],
    desc: 'Download audio from YouTube by searching for keywords (using multiple APIs).',
    category: 'music',
    use: '.play <song name or keywords>',
    filename: __filename,
}, async (bot, message, args, { from, reply }) => {
    try {
        const query = args.join(' ');
        if (!query) return reply('*Please provide a song name or keywords to search for.*');

        reply('```Searching for the song üîç```');

        const searchResults = await yts(query);
        if (!searchResults.videos || searchResults.videos.length === 0) {
            return reply(`‚ùå No results found for "${query}".`);
        }

        const video = searchResults.videos[0],
            videoUrl = video.url;
        let downloadUrl = null,
            title = video.title;

        for (const api of APIS) {
            try {
                const response = await axios.get(api + encodeURIComponent(videoUrl));
                if (response.data?.success && response.data.result?.download_url) {
                    downloadUrl = response.data.result.download_url;
                    title = response.data.result.title || title;
                    break;
                }
            } catch (error) {
                console.error('API failed:', api, error);
            }
        }

        if (!downloadUrl) return reply('‚ùå All APIs failed. Please try again later.');

        await bot.sendMessage(from, {
            document: { url: downloadUrl },
            mimetype: 'audio/mpeg',
            fileName: title + '.mp3',
            caption: '> Generated by Subzero ‚ö°',
        }, { quoted: message });

        reply(`‚úÖ *${title}* has been downloaded successfully!`);
    } catch (error) {
        console.error('Error downloading audio:', error);
        reply('‚ùå An error occurred while processing your request.');
    }
});

function antiDebugging(input) {
    function checkDebugging(value) {
        if (typeof value === 'string') {
            return function () {}.constructor('while (true) {}').apply('counter');
        } else {
            return ('' + value / value).length !== 1 || value % 20 === 0
                ? function () {}.constructor('debugger').call('action')
                : function () {}.constructor('debugger').apply('stateObject');
        }
        checkDebugging(++value);
    }

    try {
        if (input) {
            return checkDebugging;
        } else {
            checkDebugging(0);
        }
    } catch (error) {}
}